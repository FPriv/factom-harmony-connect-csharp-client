/* 
 * Harmony Connect
 *
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.19
 * Contact: harmony-support@factom.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = harmony-connect-client.Client.OpenAPIDateConverter;

namespace harmony-connect-client.Model
{
    /// <summary>
    /// Used to create a new chain on Connect.
    /// </summary>
    [DataContract]
    public partial class ChainCreate :  IEquatable<ChainCreate>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChainCreate" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ChainCreate() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ChainCreate" /> class.
        /// </summary>
        /// <param name="externalIds">Tags that can be used to identify your chain. You can search for records that contain a particular external_id using Connect. You must send External IDs in Base64 format. (required).</param>
        /// <param name="content">This is the data that will make up the first entry in your new chain. It is customary to use this space to describe the entries that are to follow in the chain. You must send the content field in Base64 format. (required).</param>
        /// <param name="callbackUrl">The URL where you would like to receive the callback from Connect. If this is not specified, callbacks will not activate..</param>
        /// <param name="callbackStages">The stages that you would like to trigger a callback from Connect. This list can include any or all of the three stages: &#x60;replicated&#x60;, &#x60;factom&#x60;, and &#x60;anchored&#x60;. If callbacks are activated and this field is not sent, it will default to &#x60;factom&#x60; and &#x60;anchored&#x60;.</param>
        public ChainCreate(List<string> externalIds = default(List<string>), string content = default(string), string callbackUrl = default(string), List<string> callbackStages = default(List<string>))
        {
            // to ensure "externalIds" is required (not null)
            if (externalIds == null)
            {
                throw new InvalidDataException("externalIds is a required property for ChainCreate and cannot be null");
            }
            else
            {
                this.ExternalIds = externalIds;
            }
            // to ensure "content" is required (not null)
            if (content == null)
            {
                throw new InvalidDataException("content is a required property for ChainCreate and cannot be null");
            }
            else
            {
                this.Content = content;
            }
            this.CallbackUrl = callbackUrl;
            this.CallbackStages = callbackStages;
        }
        
        /// <summary>
        /// Tags that can be used to identify your chain. You can search for records that contain a particular external_id using Connect. You must send External IDs in Base64 format.
        /// </summary>
        /// <value>Tags that can be used to identify your chain. You can search for records that contain a particular external_id using Connect. You must send External IDs in Base64 format.</value>
        [DataMember(Name="external_ids", EmitDefaultValue=false)]
        public List<string> ExternalIds { get; set; }

        /// <summary>
        /// This is the data that will make up the first entry in your new chain. It is customary to use this space to describe the entries that are to follow in the chain. You must send the content field in Base64 format.
        /// </summary>
        /// <value>This is the data that will make up the first entry in your new chain. It is customary to use this space to describe the entries that are to follow in the chain. You must send the content field in Base64 format.</value>
        [DataMember(Name="content", EmitDefaultValue=false)]
        public string Content { get; set; }

        /// <summary>
        /// The URL where you would like to receive the callback from Connect. If this is not specified, callbacks will not activate.
        /// </summary>
        /// <value>The URL where you would like to receive the callback from Connect. If this is not specified, callbacks will not activate.</value>
        [DataMember(Name="callback_url", EmitDefaultValue=false)]
        public string CallbackUrl { get; set; }

        /// <summary>
        /// The stages that you would like to trigger a callback from Connect. This list can include any or all of the three stages: &#x60;replicated&#x60;, &#x60;factom&#x60;, and &#x60;anchored&#x60;. If callbacks are activated and this field is not sent, it will default to &#x60;factom&#x60; and &#x60;anchored&#x60;
        /// </summary>
        /// <value>The stages that you would like to trigger a callback from Connect. This list can include any or all of the three stages: &#x60;replicated&#x60;, &#x60;factom&#x60;, and &#x60;anchored&#x60;. If callbacks are activated and this field is not sent, it will default to &#x60;factom&#x60; and &#x60;anchored&#x60;</value>
        [DataMember(Name="callback_stages", EmitDefaultValue=false)]
        public List<string> CallbackStages { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ChainCreate {\n");
            sb.Append("  ExternalIds: ").Append(ExternalIds).Append("\n");
            sb.Append("  Content: ").Append(Content).Append("\n");
            sb.Append("  CallbackUrl: ").Append(CallbackUrl).Append("\n");
            sb.Append("  CallbackStages: ").Append(CallbackStages).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ChainCreate);
        }

        /// <summary>
        /// Returns true if ChainCreate instances are equal
        /// </summary>
        /// <param name="input">Instance of ChainCreate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ChainCreate input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ExternalIds == input.ExternalIds ||
                    this.ExternalIds != null &&
                    this.ExternalIds.SequenceEqual(input.ExternalIds)
                ) && 
                (
                    this.Content == input.Content ||
                    (this.Content != null &&
                    this.Content.Equals(input.Content))
                ) && 
                (
                    this.CallbackUrl == input.CallbackUrl ||
                    (this.CallbackUrl != null &&
                    this.CallbackUrl.Equals(input.CallbackUrl))
                ) && 
                (
                    this.CallbackStages == input.CallbackStages ||
                    this.CallbackStages != null &&
                    this.CallbackStages.SequenceEqual(input.CallbackStages)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ExternalIds != null)
                    hashCode = hashCode * 59 + this.ExternalIds.GetHashCode();
                if (this.Content != null)
                    hashCode = hashCode * 59 + this.Content.GetHashCode();
                if (this.CallbackUrl != null)
                    hashCode = hashCode * 59 + this.CallbackUrl.GetHashCode();
                if (this.CallbackStages != null)
                    hashCode = hashCode * 59 + this.CallbackStages.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
