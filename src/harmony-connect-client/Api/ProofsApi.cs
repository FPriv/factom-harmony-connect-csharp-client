/* 
 * Harmony Connect
 *
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.19
 * Contact: harmony-support@factom.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using harmony-connect-client.Client;
using harmony-connect-client.Model;

namespace harmony-connect-client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProofsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Get Object&#39;s Anchors
        /// </summary>
        /// <remarks>
        /// Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>AnchorLong</returns>
        AnchorLong GetAnchorbySearch (string objectId);

        /// <summary>
        /// Get Object&#39;s Anchors
        /// </summary>
        /// <remarks>
        /// Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>ApiResponse of AnchorLong</returns>
        ApiResponse<AnchorLong> GetAnchorbySearchWithHttpInfo (string objectId);
        /// <summary>
        /// Get Entry&#39;s Receipts
        /// </summary>
        /// <remarks>
        /// Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>ReceiptLong</returns>
        ReceiptLong GetReceiptsbyEntry (string entryHash);

        /// <summary>
        /// Get Entry&#39;s Receipts
        /// </summary>
        /// <remarks>
        /// Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>ApiResponse of ReceiptLong</returns>
        ApiResponse<ReceiptLong> GetReceiptsbyEntryWithHttpInfo (string entryHash);
        /// <summary>
        /// Search
        /// </summary>
        /// <remarks>
        /// Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>InlineResponse200</returns>
        InlineResponse200 GetSearch (string term = null, string allowedStages = null);

        /// <summary>
        /// Search
        /// </summary>
        /// <remarks>
        /// Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>ApiResponse of InlineResponse200</returns>
        ApiResponse<InlineResponse200> GetSearchWithHttpInfo (string term = null, string allowedStages = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Get Object&#39;s Anchors
        /// </summary>
        /// <remarks>
        /// Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>Task of AnchorLong</returns>
        System.Threading.Tasks.Task<AnchorLong> GetAnchorbySearchAsync (string objectId);

        /// <summary>
        /// Get Object&#39;s Anchors
        /// </summary>
        /// <remarks>
        /// Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>Task of ApiResponse (AnchorLong)</returns>
        System.Threading.Tasks.Task<ApiResponse<AnchorLong>> GetAnchorbySearchAsyncWithHttpInfo (string objectId);
        /// <summary>
        /// Get Entry&#39;s Receipts
        /// </summary>
        /// <remarks>
        /// Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>Task of ReceiptLong</returns>
        System.Threading.Tasks.Task<ReceiptLong> GetReceiptsbyEntryAsync (string entryHash);

        /// <summary>
        /// Get Entry&#39;s Receipts
        /// </summary>
        /// <remarks>
        /// Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>Task of ApiResponse (ReceiptLong)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReceiptLong>> GetReceiptsbyEntryAsyncWithHttpInfo (string entryHash);
        /// <summary>
        /// Search
        /// </summary>
        /// <remarks>
        /// Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>Task of InlineResponse200</returns>
        System.Threading.Tasks.Task<InlineResponse200> GetSearchAsync (string term = null, string allowedStages = null);

        /// <summary>
        /// Search
        /// </summary>
        /// <remarks>
        /// Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </remarks>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse200)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse200>> GetSearchAsyncWithHttpInfo (string term = null, string allowedStages = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ProofsApi : IProofsApi
    {
        private harmony-connect-client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProofsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProofsApi(String basePath)
        {
            this.Configuration = new harmony-connect-client.Client.Configuration { BasePath = basePath };

            ExceptionFactory = harmony-connect-client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProofsApi"/> class
        /// </summary>
        /// <returns></returns>
        public ProofsApi()
        {
            this.Configuration = harmony-connect-client.Client.Configuration.Default;

            ExceptionFactory = harmony-connect-client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProofsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ProofsApi(harmony-connect-client.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = harmony-connect-client.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = harmony-connect-client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public harmony-connect-client.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public harmony-connect-client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Get Object&#39;s Anchors Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>AnchorLong</returns>
        public AnchorLong GetAnchorbySearch (string objectId)
        {
             ApiResponse<AnchorLong> localVarResponse = GetAnchorbySearchWithHttpInfo(objectId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Object&#39;s Anchors Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>ApiResponse of AnchorLong</returns>
        public ApiResponse< AnchorLong > GetAnchorbySearchWithHttpInfo (string objectId)
        {
            // verify the required parameter 'objectId' is set
            if (objectId == null)
                throw new ApiException(400, "Missing required parameter 'objectId' when calling ProofsApi->GetAnchorbySearch");

            var localVarPath = "/anchors/{object_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (objectId != null) localVarPathParams.Add("object_id", this.Configuration.ApiClient.ParameterToString(objectId)); // path parameter

            // authentication (AppId) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_id")))
            {
                localVarHeaderParams["app_id"] = this.Configuration.GetApiKeyWithPrefix("app_id");
            }
            // authentication (AppKey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_key")))
            {
                localVarHeaderParams["app_key"] = this.Configuration.GetApiKeyWithPrefix("app_key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAnchorbySearch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnchorLong>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AnchorLong) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnchorLong)));
        }

        /// <summary>
        /// Get Object&#39;s Anchors Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>Task of AnchorLong</returns>
        public async System.Threading.Tasks.Task<AnchorLong> GetAnchorbySearchAsync (string objectId)
        {
             ApiResponse<AnchorLong> localVarResponse = await GetAnchorbySearchAsyncWithHttpInfo(objectId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Object&#39;s Anchors Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="objectId">Object identifier.  Used to identify an entry, chain, or block that has been published on the Factom blockchain. These objects can be identified by their hash, ID, height, or key Merkle root.</param>
        /// <returns>Task of ApiResponse (AnchorLong)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AnchorLong>> GetAnchorbySearchAsyncWithHttpInfo (string objectId)
        {
            // verify the required parameter 'objectId' is set
            if (objectId == null)
                throw new ApiException(400, "Missing required parameter 'objectId' when calling ProofsApi->GetAnchorbySearch");

            var localVarPath = "/anchors/{object_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (objectId != null) localVarPathParams.Add("object_id", this.Configuration.ApiClient.ParameterToString(objectId)); // path parameter

            // authentication (AppId) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_id")))
            {
                localVarHeaderParams["app_id"] = this.Configuration.GetApiKeyWithPrefix("app_id");
            }
            // authentication (AppKey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_key")))
            {
                localVarHeaderParams["app_key"] = this.Configuration.GetApiKeyWithPrefix("app_key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAnchorbySearch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnchorLong>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AnchorLong) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnchorLong)));
        }

        /// <summary>
        /// Get Entry&#39;s Receipts Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>ReceiptLong</returns>
        public ReceiptLong GetReceiptsbyEntry (string entryHash)
        {
             ApiResponse<ReceiptLong> localVarResponse = GetReceiptsbyEntryWithHttpInfo(entryHash);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Entry&#39;s Receipts Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>ApiResponse of ReceiptLong</returns>
        public ApiResponse< ReceiptLong > GetReceiptsbyEntryWithHttpInfo (string entryHash)
        {
            // verify the required parameter 'entryHash' is set
            if (entryHash == null)
                throw new ApiException(400, "Missing required parameter 'entryHash' when calling ProofsApi->GetReceiptsbyEntry");

            var localVarPath = "/receipts/{entry_hash}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entryHash != null) localVarPathParams.Add("entry_hash", this.Configuration.ApiClient.ParameterToString(entryHash)); // path parameter

            // authentication (AppId) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_id")))
            {
                localVarHeaderParams["app_id"] = this.Configuration.GetApiKeyWithPrefix("app_id");
            }
            // authentication (AppKey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_key")))
            {
                localVarHeaderParams["app_key"] = this.Configuration.GetApiKeyWithPrefix("app_key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetReceiptsbyEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ReceiptLong>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ReceiptLong) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ReceiptLong)));
        }

        /// <summary>
        /// Get Entry&#39;s Receipts Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>Task of ReceiptLong</returns>
        public async System.Threading.Tasks.Task<ReceiptLong> GetReceiptsbyEntryAsync (string entryHash)
        {
             ApiResponse<ReceiptLong> localVarResponse = await GetReceiptsbyEntryAsyncWithHttpInfo(entryHash);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Entry&#39;s Receipts Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entryHash">The unique identitfier of the entry.</param>
        /// <returns>Task of ApiResponse (ReceiptLong)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ReceiptLong>> GetReceiptsbyEntryAsyncWithHttpInfo (string entryHash)
        {
            // verify the required parameter 'entryHash' is set
            if (entryHash == null)
                throw new ApiException(400, "Missing required parameter 'entryHash' when calling ProofsApi->GetReceiptsbyEntry");

            var localVarPath = "/receipts/{entry_hash}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entryHash != null) localVarPathParams.Add("entry_hash", this.Configuration.ApiClient.ParameterToString(entryHash)); // path parameter

            // authentication (AppId) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_id")))
            {
                localVarHeaderParams["app_id"] = this.Configuration.GetApiKeyWithPrefix("app_id");
            }
            // authentication (AppKey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_key")))
            {
                localVarHeaderParams["app_key"] = this.Configuration.GetApiKeyWithPrefix("app_key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetReceiptsbyEntry", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ReceiptLong>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ReceiptLong) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ReceiptLong)));
        }

        /// <summary>
        /// Search Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>InlineResponse200</returns>
        public InlineResponse200 GetSearch (string term = null, string allowedStages = null)
        {
             ApiResponse<InlineResponse200> localVarResponse = GetSearchWithHttpInfo(term, allowedStages);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>ApiResponse of InlineResponse200</returns>
        public ApiResponse< InlineResponse200 > GetSearchWithHttpInfo (string term = null, string allowedStages = null)
        {

            var localVarPath = "/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (term != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "term", term)); // query parameter
            if (allowedStages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "allowed_stages", allowedStages)); // query parameter

            // authentication (AppId) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_id")))
            {
                localVarHeaderParams["app_id"] = this.Configuration.GetApiKeyWithPrefix("app_id");
            }
            // authentication (AppKey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_key")))
            {
                localVarHeaderParams["app_key"] = this.Configuration.GetApiKeyWithPrefix("app_key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSearch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse200>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (InlineResponse200) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse200)));
        }

        /// <summary>
        /// Search Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>Task of InlineResponse200</returns>
        public async System.Threading.Tasks.Task<InlineResponse200> GetSearchAsync (string term = null, string allowedStages = null)
        {
             ApiResponse<InlineResponse200> localVarResponse = await GetSearchAsyncWithHttpInfo(term, allowedStages);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
        /// </summary>
        /// <exception cref="harmony-connect-client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="term">The term that you are searching for. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID). (optional)</param>
        /// <param name="allowedStages">When entered, filters chain and entry responses by immutability stage. Must be either &#x60;replicated&#x60;, &#x60;factom&#x60;, or &#x60;anchored&#x60;. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse200)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse200>> GetSearchAsyncWithHttpInfo (string term = null, string allowedStages = null)
        {

            var localVarPath = "/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (term != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "term", term)); // query parameter
            if (allowedStages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "allowed_stages", allowedStages)); // query parameter

            // authentication (AppId) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_id")))
            {
                localVarHeaderParams["app_id"] = this.Configuration.GetApiKeyWithPrefix("app_id");
            }
            // authentication (AppKey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("app_key")))
            {
                localVarHeaderParams["app_key"] = this.Configuration.GetApiKeyWithPrefix("app_key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSearch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse200>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (InlineResponse200) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse200)));
        }

    }
}
